<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Transformations Tutorial &mdash; Matplotlib 2.0.0b1.post5145+g83129fa documentation</title>
    
    <link rel="stylesheet" href="../../_static/mpl.css"
type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css"
type="text/css" />
    <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.0.0b1.post5145+g83129fa',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 2.0.0b1.post5145+g83129fa documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html"
/>
    <link rel="search" title="Search" href="../../search.html"
/>
    <link rel="top" title="Matplotlib 2.0.0b1.post5145+g83129fa documentation" href="../../index.html" /> 


  </head>
  <body>



<!-- The "Fork me on github" ribbon -->
<img style="float: right; margin-bottom: -40px; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" usemap="#ribbonmap"/>
<map name="ribbonmap">
    <area shape="poly" coords="15,0,148,-1,148,135" href="https://github.com/matplotlib/matplotlib" title="Fork me on GitHub" />
</map>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo2.svg" width="540px" border="0" alt="matplotlib"/></a>
</div>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>

        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../gallery/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../api/pyplot_summary.html">pyplot</a>|&nbsp;</li>
        <li><a href="../../contents.html">docs</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<a href="http://depsy.org/package/python/matplotlib">
  <img src="../../_static/depsy_badge.svg">
</a>

<br/>

Travis-CI: <a href="https://travis-ci.org/matplotlib/matplotlib">
  <img src="https://travis-ci.org/matplotlib/matplotlib.svg?branch=master"/>
</a>
<br/>
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Transformations Tutorial</a><ul>
<li><a class="reference internal" href="#data-coordinates">Data coordinates</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/tutorials/advanced/transforms_tutorial.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="transformations-tutorial">
<span id="transforms-tutorial"></span><span id="sphx-glr-tutorials-advanced-transforms-tutorial-py"></span><h1>Transformations Tutorial<a class="headerlink" href="#transformations-tutorial" title="Permalink to this headline">¶</a></h1>
<p>Like any graphics packages, matplotlib is built on top of a
transformation framework to easily move between coordinate systems,
the userland <code class="xref py py-obj docutils literal"><span class="pre">data</span></code> coordinate system, the <code class="xref py py-obj docutils literal"><span class="pre">axes</span></code> coordinate system,
the <code class="xref py py-obj docutils literal"><span class="pre">figure</span></code> coordinate system, and the <code class="xref py py-obj docutils literal"><span class="pre">display</span></code> coordinate system.
In 95% of your plotting, you won&#8217;t need to think about this, as it
happens under the hood, but as you push the limits of custom figure
generation, it helps to have an understanding of these objects so you
can reuse the existing transformations matplotlib makes available to
you, or create your own (see <a class="reference internal" href="../../api/transformations.html#module-matplotlib.transforms" title="matplotlib.transforms"><code class="xref py py-mod docutils literal"><span class="pre">matplotlib.transforms</span></code></a>).  The table
below summarizes the existing coordinate systems, the transformation
object you should use to work in that coordinate system, and the
description of that system. In the <code class="xref py py-obj docutils literal"><span class="pre">Transformation</span> <span class="pre">Object</span></code> column,
<code class="docutils literal"><span class="pre">ax</span></code> is a <a class="reference internal" href="../../api/axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code class="xref py py-class docutils literal"><span class="pre">Axes</span></code></a> instance, and <code class="docutils literal"><span class="pre">fig</span></code> is a
<a class="reference internal" href="../../api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code class="xref py py-class docutils literal"><span class="pre">Figure</span></code></a> instance.</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="18%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Coordinate</th>
<th class="head">Transformation Object</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">data</span></code></td>
<td><code class="docutils literal"><span class="pre">ax.transData</span></code></td>
<td>The userland data coordinate system, controlled by the xlim and ylim</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">axes</span></code></td>
<td><code class="docutils literal"><span class="pre">ax.transAxes</span></code></td>
<td>The coordinate system of the <a class="reference internal" href="../../api/axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code class="xref py py-class docutils literal"><span class="pre">Axes</span></code></a>; (0,0) is
bottom left of the axes, and (1,1) is top right of the axes.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">figure</span></code></td>
<td><code class="docutils literal"><span class="pre">fig.transFigure</span></code></td>
<td>The coordinate system of the <a class="reference internal" href="../../api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code class="xref py py-class docutils literal"><span class="pre">Figure</span></code></a>; (0,0)
is bottom left of the figure, and (1,1) is top right of the figure.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">display</span></code></td>
<td><code class="xref py py-obj docutils literal"><span class="pre">None</span></code></td>
<td>This is the pixel coordinate system of the display; (0,0) is the bottom
left of the display, and (width, height) is the top right of the display in pixels.
Alternatively, the identity transform
(<a class="reference internal" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform" title="matplotlib.transforms.IdentityTransform"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.transforms.IdentityTransform()</span></code></a>) may be used instead of None.</td>
</tr>
</tbody>
</table>
<p>All of the transformation objects in the table above take inputs in
their coordinate system, and transform the input to the <code class="xref py py-obj docutils literal"><span class="pre">display</span></code>
coordinate system.  That is why the <code class="xref py py-obj docutils literal"><span class="pre">display</span></code> coordinate system has
<code class="xref py py-obj docutils literal"><span class="pre">None</span></code> for the <code class="xref py py-obj docutils literal"><span class="pre">Transformation</span> <span class="pre">Object</span></code> column &#8211; it already is in
display coordinates.  The transformations also know how to invert
themselves, to go from <code class="xref py py-obj docutils literal"><span class="pre">display</span></code> back to the native coordinate system.
This is particularly useful when processing events from the user
interface, which typically occur in display space, and you want to
know where the mouse click or key-press occurred in your data
coordinate system.</p>
<div class="section" id="data-coordinates">
<span id="data-coords"></span><h2>Data coordinates<a class="headerlink" href="#data-coordinates" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s start with the most commonly used coordinate, the <code class="xref py py-obj docutils literal"><span class="pre">data</span></code>
coordinate system.  Whenever you add data to the axes, matplotlib
updates the datalimits, most commonly updated with the
<a class="reference internal" href="../../api/_as_gen/matplotlib.axes.Axes.set_xlim.html#matplotlib.axes.Axes.set_xlim" title="matplotlib.axes.Axes.set_xlim"><code class="xref py py-meth docutils literal"><span class="pre">set_xlim()</span></code></a> and
<a class="reference internal" href="../../api/_as_gen/matplotlib.axes.Axes.set_ylim.html#matplotlib.axes.Axes.set_ylim" title="matplotlib.axes.Axes.set_ylim"><code class="xref py py-meth docutils literal"><span class="pre">set_ylim()</span></code></a> methods.  For example, in the
figure below, the data limits stretch from 0 to 10 on the x-axis, and
-1 to 1 on the y-axis.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># .. plot::</span>
<span class="c1">#    :include-source:</span>

<span class="c1">#    import numpy as np</span>
<span class="c1">#    import matplotlib.pyplot as plt</span>

<span class="c1">#    x = np.arange(0, 10, 0.005)</span>
<span class="c1">#    y = np.exp(-x/2.) * np.sin(2*np.pi*x)</span>

<span class="c1">#    fig = plt.figure()</span>
<span class="c1">#    ax = fig.add_subplot(111)</span>
<span class="c1">#    ax.plot(x, y)</span>
<span class="c1">#    ax.set_xlim(0, 10)</span>
<span class="c1">#    ax.set_ylim(-1, 1)</span>

<span class="c1">#    plt.show()</span>

<span class="c1"># You can use the ``ax.transData`` instance to transform from your</span>
<span class="c1"># `data` to your `display` coordinate system, either a single point or a</span>
<span class="c1"># sequence of points as shown below:</span>

<span class="c1"># .. sourcecode:: ipython</span>

<span class="c1">#     In [14]: type(ax.transData)</span>
<span class="c1">#     Out[14]: &lt;class &#39;matplotlib.transforms.CompositeGenericTransform&#39;&gt;</span>

<span class="c1">#     In [15]: ax.transData.transform((5, 0))</span>
<span class="c1">#     Out[15]: array([ 335.175,  247.   ])</span>

<span class="c1">#     In [16]: ax.transData.transform([(5, 0), (1,2)])</span>
<span class="c1">#     Out[16]:</span>
<span class="c1">#     array([[ 335.175,  247.   ],</span>
<span class="c1">#            [ 132.435,  642.2  ]])</span>

<span class="c1"># You can use the :meth:`~matplotlib.transforms.Transform.inverted`</span>
<span class="c1"># method to create a transform which will take you from display to data</span>
<span class="c1"># coordinates:</span>

<span class="c1"># .. sourcecode:: ipython</span>

<span class="c1">#     In [41]: inv = ax.transData.inverted()</span>

<span class="c1">#     In [42]: type(inv)</span>
<span class="c1">#     Out[42]: &lt;class &#39;matplotlib.transforms.CompositeGenericTransform&#39;&gt;</span>

<span class="c1">#     In [43]: inv.transform((335.175,  247.))</span>
<span class="c1">#     Out[43]: array([ 5.,  0.])</span>

<span class="c1"># If your are typing along with this tutorial, the exact values of the</span>
<span class="c1"># display coordinates may differ if you have a different window size or</span>
<span class="c1"># dpi setting.  Likewise, in the figure below, the display labeled</span>
<span class="c1"># points are probably not the same as in the ipython session because the</span>
<span class="c1"># documentation figure size defaults are different.</span>

<span class="c1"># .. figure:: ../gallery/pyplots/images/sphx_glr_annotate_transform_001.png</span>
<span class="c1">#    :target: ../gallery/pyplots/annotate_transform.html</span>
<span class="c1">#    :align: center</span>
<span class="c1">#    :scale: 50</span>

<span class="c1">#    Annotate Transform</span>


<span class="c1"># .. note::</span>

<span class="c1">#   If you run the source code in the example above in a GUI backend,</span>
<span class="c1">#   you may also find that the two arrows for the `data` and `display`</span>
<span class="c1">#   annotations do not point to exactly the same point.  This is because</span>
<span class="c1">#   the display point was computed before the figure was displayed, and</span>
<span class="c1">#   the GUI backend may slightly resize the figure when it is created.</span>
<span class="c1">#   The effect is more pronounced if you resize the figure yourself.</span>
<span class="c1">#   This is one good reason why you rarely want to work in display</span>
<span class="c1">#   space, but you can connect to the ``&#39;on_draw&#39;``</span>
<span class="c1">#   :class:`~matplotlib.backend_bases.Event` to update figure</span>
<span class="c1">#   coordinates on figure draws; see :ref:`event-handling-tutorial`.</span>

<span class="c1"># When you change the x or y limits of your axes, the data limits are</span>
<span class="c1"># updated so the transformation yields a new display point.  Note that</span>
<span class="c1"># when we just change the ylim, only the y-display coordinate is</span>
<span class="c1"># altered, and when we change the xlim too, both are altered.  More on</span>
<span class="c1"># this later when we talk about the</span>
<span class="c1"># :class:`~matplotlib.transforms.Bbox`.</span>

<span class="c1"># .. sourcecode:: ipython</span>

<span class="c1">#     In [54]: ax.transData.transform((5, 0))</span>
<span class="c1">#     Out[54]: array([ 335.175,  247.   ])</span>

<span class="c1">#     In [55]: ax.set_ylim(-1,2)</span>
<span class="c1">#     Out[55]: (-1, 2)</span>

<span class="c1">#     In [56]: ax.transData.transform((5, 0))</span>
<span class="c1">#     Out[56]: array([ 335.175     ,  181.13333333])</span>

<span class="c1">#     In [57]: ax.set_xlim(10,20)</span>
<span class="c1">#     Out[57]: (10, 20)</span>

<span class="c1">#     In [58]: ax.transData.transform((5, 0))</span>
<span class="c1">#     Out[58]: array([-171.675     ,  181.13333333])</span>



<span class="c1"># .. _axes-coords:</span>

<span class="c1"># Axes coordinates</span>
<span class="c1"># ================</span>

<span class="c1"># After the `data` coordinate system, `axes` is probably the second most</span>
<span class="c1"># useful coordinate system.  Here the point (0,0) is the bottom left of</span>
<span class="c1"># your axes or subplot, (0.5, 0.5) is the center, and (1.0, 1.0) is the</span>
<span class="c1"># top right.  You can also refer to points outside the range, so (-0.1,</span>
<span class="c1"># 1.1) is to the left and above your axes.  This coordinate system is</span>
<span class="c1"># extremely useful when placing text in your axes, because you often</span>
<span class="c1"># want a text bubble in a fixed, location, e.g., the upper left of the axes</span>
<span class="c1"># pane, and have that location remain fixed when you pan or zoom.  Here</span>
<span class="c1"># is a simple example that creates four panels and labels them &#39;A&#39;, &#39;B&#39;,</span>
<span class="c1"># &#39;C&#39;, &#39;D&#39; as you often see in journals.</span>

<span class="c1"># .. plot::</span>
<span class="c1">#    :include-source:</span>

<span class="c1">#    import numpy as np</span>
<span class="c1">#    import matplotlib.pyplot as plt</span>

<span class="c1">#    fig = plt.figure()</span>
<span class="c1">#    for i, label in enumerate((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;)):</span>
<span class="c1">#        ax = fig.add_subplot(2,2,i+1)</span>
<span class="c1">#        ax.text(0.05, 0.95, label, transform=ax.transAxes,</span>
<span class="c1">#          fontsize=16, fontweight=&#39;bold&#39;, va=&#39;top&#39;)</span>

<span class="c1">#    plt.show()</span>

<span class="c1"># You can also make lines or patches in the axes coordinate system, but</span>
<span class="c1"># this is less useful in my experience than using ``ax.transAxes`` for</span>
<span class="c1"># placing text.  Nonetheless, here is a silly example which plots some</span>
<span class="c1"># random dots in `data` space, and overlays a semi-transparent</span>
<span class="c1"># :class:`~matplotlib.patches.Circle` centered in the middle of the axes</span>
<span class="c1"># with a radius one quarter of the axes -- if your axes does not</span>
<span class="c1"># preserve aspect ratio (see :meth:`~matplotlib.axes.Axes.set_aspect`),</span>
<span class="c1"># this will look like an ellipse.  Use the pan/zoom tool to move around,</span>
<span class="c1"># or manually change the data xlim and ylim, and you will see the data</span>
<span class="c1"># move, but the circle will remain fixed because it is not in `data`</span>
<span class="c1"># coordinates and will always remain at the center of the axes.</span>

<span class="c1"># .. plot::</span>
<span class="c1">#    :include-source:</span>

<span class="c1">#    import numpy as np</span>
<span class="c1">#    import matplotlib.pyplot as plt</span>
<span class="c1">#    import matplotlib.patches as patches</span>
<span class="c1">#    fig = plt.figure()</span>
<span class="c1">#    ax = fig.add_subplot(111)</span>
<span class="c1">#    x, y = 10*np.random.rand(2, 1000)</span>
<span class="c1">#    ax.plot(x, y, &#39;go&#39;)  # plot some data in data coordinates</span>

<span class="c1">#    circ = patches.Circle((0.5, 0.5), 0.25, transform=ax.transAxes,</span>
<span class="c1">#                          facecolor=&#39;yellow&#39;, alpha=0.5)</span>
<span class="c1">#    ax.add_patch(circ)</span>

<span class="c1">#    plt.show()</span>

<span class="c1"># .. blended_transformations:</span>

<span class="c1"># Blended transformations</span>
<span class="c1"># =======================</span>

<span class="c1"># Drawing in `blended` coordinate spaces which mix `axes` with `data`</span>
<span class="c1"># coordinates is extremely useful, for example to create a horizontal</span>
<span class="c1"># span which highlights some region of the y-data but spans across the</span>
<span class="c1"># x-axis regardless of the data limits, pan or zoom level, etc.  In fact</span>
<span class="c1"># these blended lines and spans are so useful, we have built in</span>
<span class="c1"># functions to make them easy to plot (see</span>
<span class="c1"># :meth:`~matplotlib.axes.Axes.axhline`,</span>
<span class="c1"># :meth:`~matplotlib.axes.Axes.axvline`,</span>
<span class="c1"># :meth:`~matplotlib.axes.Axes.axhspan`,</span>
<span class="c1"># :meth:`~matplotlib.axes.Axes.axvspan`) but for didactic purposes we</span>
<span class="c1"># will implement the horizontal span here using a blended</span>
<span class="c1"># transformation.  This trick only works for separable transformations,</span>
<span class="c1"># like you see in normal Cartesian coordinate systems, but not on</span>
<span class="c1"># inseparable transformations like the</span>
<span class="c1"># :class:`~matplotlib.projections.polar.PolarAxes.PolarTransform`.</span>

<span class="c1"># .. plot::</span>
<span class="c1">#    :include-source:</span>

<span class="c1">#    import numpy as np</span>
<span class="c1">#    import matplotlib.pyplot as plt</span>
<span class="c1">#    import matplotlib.patches as patches</span>
<span class="c1">#    import matplotlib.transforms as transforms</span>

<span class="c1">#    fig = plt.figure()</span>
<span class="c1">#    ax = fig.add_subplot(111)</span>

<span class="c1">#    x = np.random.randn(1000)</span>

<span class="c1">#    ax.hist(x, 30)</span>
<span class="c1">#    ax.set_title(r&#39;$\sigma=1 \/ \dots \/ \sigma=2$&#39;, fontsize=16)</span>

<span class="c1">#    # the x coords of this transformation are data, and the</span>
<span class="c1">#    # y coord are axes</span>
<span class="c1">#    trans = transforms.blended_transform_factory(</span>
<span class="c1">#        ax.transData, ax.transAxes)</span>

<span class="c1">#    # highlight the 1..2 stddev region with a span.</span>
<span class="c1">#    # We want x to be in data coordinates and y to</span>
<span class="c1">#    # span from 0..1 in axes coords</span>
<span class="c1">#    rect = patches.Rectangle((1,0), width=1, height=1,</span>
<span class="c1">#                             transform=trans, color=&#39;yellow&#39;,</span>
<span class="c1">#                             alpha=0.5)</span>

<span class="c1">#    ax.add_patch(rect)</span>

<span class="c1">#    plt.show()</span>

<span class="c1"># .. note::</span>

<span class="c1">#   The blended transformations where x is in data coords and y in axes</span>
<span class="c1">#   coordinates is so useful that we have helper methods to return the</span>
<span class="c1">#   versions mpl uses internally for drawing ticks, ticklabels, etc.</span>
<span class="c1">#   The methods are :meth:`matplotlib.axes.Axes.get_xaxis_transform` and</span>
<span class="c1">#   :meth:`matplotlib.axes.Axes.get_yaxis_transform`.  So in the example</span>
<span class="c1">#   above, the call to</span>
<span class="c1">#   :meth:`~matplotlib.transforms.blended_transform_factory` can be</span>
<span class="c1">#   replaced by ``get_xaxis_transform``::</span>

<span class="c1">#     trans = ax.get_xaxis_transform()</span>

<span class="c1"># .. offset-transforms-shadow:</span>

<span class="c1"># Using offset transforms to create a shadow effect</span>
<span class="c1"># =================================================</span>

<span class="c1"># One use of transformations is to create a new transformation that is</span>
<span class="c1"># offset from another transformation, e.g., to place one object shifted a</span>
<span class="c1"># bit relative to another object.  Typically you want the shift to be in</span>
<span class="c1"># some physical dimension, like points or inches rather than in data</span>
<span class="c1"># coordinates, so that the shift effect is constant at different zoom</span>
<span class="c1"># levels and dpi settings.</span>

<span class="c1"># One use for an offset is to create a shadow effect, where you draw one</span>
<span class="c1"># object identical to the first just to the right of it, and just below</span>
<span class="c1"># it, adjusting the zorder to make sure the shadow is drawn first and</span>
<span class="c1"># then the object it is shadowing above it.  The transforms module has a</span>
<span class="c1"># helper transformation</span>
<span class="c1"># :class:`~matplotlib.transforms.ScaledTranslation`.  It is</span>
<span class="c1"># instantiated with::</span>

<span class="c1">#   trans = ScaledTranslation(xt, yt, scale_trans)</span>

<span class="c1"># where `xt` and `yt` are the translation offsets, and `scale_trans` is</span>
<span class="c1"># a transformation which scales `xt` and `yt` at transformation time</span>
<span class="c1"># before applying the offsets.  A typical use case is to use the figure</span>
<span class="c1"># ``fig.dpi_scale_trans`` transformation for the `scale_trans` argument,</span>
<span class="c1"># to first scale `xt` and `yt` specified in points to `display` space</span>
<span class="c1"># before doing the final offset.  The dpi and inches offset is a</span>
<span class="c1"># common-enough use case that we have a special helper function to</span>
<span class="c1"># create it in :func:`matplotlib.transforms.offset_copy`, which returns</span>
<span class="c1"># a new transform with an added offset.  But in the example below, we&#39;ll</span>
<span class="c1"># create the offset transform ourselves.  Note the use of the plus</span>
<span class="c1"># operator in::</span>

<span class="c1">#     offset = transforms.ScaledTranslation(dx, dy,</span>
<span class="c1">#       fig.dpi_scale_trans)</span>
<span class="c1">#     shadow_transform = ax.transData + offset</span>

<span class="c1"># showing that can chain transformations using the addition operator.</span>
<span class="c1"># This code says: first apply the data transformation ``ax.transData``</span>
<span class="c1"># and then translate the data by `dx` and `dy` points.  In typography,</span>
<span class="c1"># a`point &lt;https://en.wikipedia.org/wiki/Point_%28typography%29&gt;`_ is</span>
<span class="c1"># 1/72 inches, and by specifying your offsets in points, your figure</span>
<span class="c1"># will look the same regardless of the dpi resolution it is saved in.</span>

<span class="c1"># .. plot::</span>
<span class="c1">#    :include-source:</span>

<span class="c1">#    import numpy as np</span>
<span class="c1">#    import matplotlib.pyplot as plt</span>
<span class="c1">#    import matplotlib.patches as patches</span>
<span class="c1">#    import matplotlib.transforms as transforms</span>

<span class="c1">#    fig = plt.figure()</span>
<span class="c1">#    ax = fig.add_subplot(111)</span>

<span class="c1">#    # make a simple sine wave</span>
<span class="c1">#    x = np.arange(0., 2., 0.01)</span>
<span class="c1">#    y = np.sin(2*np.pi*x)</span>
<span class="c1">#    line, = ax.plot(x, y, lw=3, color=&#39;blue&#39;)</span>

<span class="c1">#    # shift the object over 2 points, and down 2 points</span>
<span class="c1">#    dx, dy = 2/72., -2/72.</span>
<span class="c1">#    offset = transforms.ScaledTranslation(dx, dy,</span>
<span class="c1">#      fig.dpi_scale_trans)</span>
<span class="c1">#    shadow_transform = ax.transData + offset</span>

<span class="c1">#    # now plot the same data with our offset transform;</span>
<span class="c1">#    # use the zorder to make sure we are below the line</span>
<span class="c1">#    ax.plot(x, y, lw=3, color=&#39;gray&#39;,</span>
<span class="c1">#      transform=shadow_transform,</span>
<span class="c1">#      zorder=0.5*line.get_zorder())</span>

<span class="c1">#    ax.set_title(&#39;creating a shadow effect with an offset transform&#39;)</span>
<span class="c1">#    plt.show()</span>


<span class="c1"># .. transformation-pipeline:</span>

<span class="c1"># The transformation pipeline</span>
<span class="c1"># ===========================</span>

<span class="c1"># The ``ax.transData`` transform we have been working with in this</span>
<span class="c1"># tutorial is a composite of three different transformations that</span>
<span class="c1"># comprise the transformation pipeline from `data` -&gt; `display`</span>
<span class="c1"># coordinates.  Michael Droettboom implemented the transformations</span>
<span class="c1"># framework, taking care to provide a clean API that segregated the</span>
<span class="c1"># nonlinear projections and scales that happen in polar and logarithmic</span>
<span class="c1"># plots, from the linear affine transformations that happen when you pan</span>
<span class="c1"># and zoom.  There is an efficiency here, because you can pan and zoom</span>
<span class="c1"># in your axes which affects the affine transformation, but you may not</span>
<span class="c1"># need to compute the potentially expensive nonlinear scales or</span>
<span class="c1"># projections on simple navigation events.  It is also possible to</span>
<span class="c1"># multiply affine transformation matrices together, and then apply them</span>
<span class="c1"># to coordinates in one step.  This is not true of all possible</span>
<span class="c1"># transformations.</span>


<span class="c1"># Here is how the ``ax.transData`` instance is defined in the basic</span>
<span class="c1"># separable axis :class:`~matplotlib.axes.Axes` class::</span>

<span class="c1">#   self.transData = self.transScale + (self.transLimits + self.transAxes)</span>

<span class="c1"># We&#39;ve been introduced to the ``transAxes`` instance above in</span>
<span class="c1"># :ref:`axes-coords`, which maps the (0,0), (1,1) corners of the</span>
<span class="c1"># axes or subplot bounding box to `display` space, so let&#39;s look at</span>
<span class="c1"># these other two pieces.</span>

<span class="c1"># ``self.transLimits`` is the transformation that takes you from</span>
<span class="c1"># ``data`` to ``axes`` coordinates; i.e., it maps your view xlim and ylim</span>
<span class="c1"># to the unit space of the axes (and ``transAxes`` then takes that unit</span>
<span class="c1"># space to display space).  We can see this in action here</span>

<span class="c1"># .. sourcecode:: ipython</span>

<span class="c1">#     In [80]: ax = subplot(111)</span>

<span class="c1">#     In [81]: ax.set_xlim(0, 10)</span>
<span class="c1">#     Out[81]: (0, 10)</span>

<span class="c1">#     In [82]: ax.set_ylim(-1,1)</span>
<span class="c1">#     Out[82]: (-1, 1)</span>

<span class="c1">#     In [84]: ax.transLimits.transform((0,-1))</span>
<span class="c1">#     Out[84]: array([ 0.,  0.])</span>

<span class="c1">#     In [85]: ax.transLimits.transform((10,-1))</span>
<span class="c1">#     Out[85]: array([ 1.,  0.])</span>

<span class="c1">#     In [86]: ax.transLimits.transform((10,1))</span>
<span class="c1">#     Out[86]: array([ 1.,  1.])</span>

<span class="c1">#     In [87]: ax.transLimits.transform((5,0))</span>
<span class="c1">#     Out[87]: array([ 0.5,  0.5])</span>

<span class="c1"># and we can use this same inverted transformation to go from the unit</span>
<span class="c1"># `axes` coordinates back to `data` coordinates.</span>

<span class="c1"># .. sourcecode:: ipython</span>

<span class="c1">#     In [90]: inv.transform((0.25, 0.25))</span>
<span class="c1">#     Out[90]: array([ 2.5, -0.5])</span>

<span class="c1"># The final piece is the ``self.transScale`` attribute, which is</span>
<span class="c1"># responsible for the optional non-linear scaling of the data, e.g., for</span>
<span class="c1"># logarithmic axes.  When an Axes is initially setup, this is just set to</span>
<span class="c1"># the identity transform, since the basic matplotlib axes has linear</span>
<span class="c1"># scale, but when you call a logarithmic scaling function like</span>
<span class="c1"># :meth:`~matplotlib.axes.Axes.semilogx` or explicitly set the scale to</span>
<span class="c1"># logarithmic with :meth:`~matplotlib.axes.Axes.set_xscale`, then the</span>
<span class="c1"># ``ax.transScale`` attribute is set to handle the nonlinear projection.</span>
<span class="c1"># The scales transforms are properties of the respective ``xaxis`` and</span>
<span class="c1"># ``yaxis`` :class:`~matplotlib.axis.Axis` instances.  For example, when</span>
<span class="c1"># you call ``ax.set_xscale(&#39;log&#39;)``, the xaxis updates its scale to a</span>
<span class="c1"># :class:`matplotlib.scale.LogScale` instance.</span>

<span class="c1"># For non-separable axes the PolarAxes, there is one more piece to</span>
<span class="c1"># consider, the projection transformation.  The ``transData``</span>
<span class="c1"># :class:`matplotlib.projections.polar.PolarAxes` is similar to that for</span>
<span class="c1"># the typical separable matplotlib Axes, with one additional piece</span>
<span class="c1"># ``transProjection``::</span>

<span class="c1">#       self.transData = self.transScale + self.transProjection + \</span>
<span class="c1">#           (self.transProjectionAffine + self.transAxes)</span>

<span class="c1"># ``transProjection`` handles the projection from the space,</span>
<span class="c1"># e.g., latitude and longitude for map data, or radius and theta for polar</span>
<span class="c1"># data, to a separable Cartesian coordinate system.  There are several</span>
<span class="c1"># projection examples in the ``matplotlib.projections`` package, and the</span>
<span class="c1"># best way to learn more is to open the source for those packages and</span>
<span class="c1"># see how to make your own, since matplotlib supports extensible axes</span>
<span class="c1"># and projections.  Michael Droettboom has provided a nice tutorial</span>
<span class="c1"># example of creating a hammer projection axes; see</span>
<span class="c1"># :ref:`api-custom_projection_example`.</span>
</pre></div>
</div>
<p><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>
<div class="sphx-glr-footer docutils container">
<div class="sphx-glr-download docutils container">
<a class="reference download internal" href="../../_downloads/transforms_tutorial.py" download=""><code class="xref download docutils literal"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">transforms_tutorial.py</span></code></a></div>
<div class="sphx-glr-download docutils container">
<a class="reference download internal" href="../../_downloads/transforms_tutorial.ipynb" download=""><code class="xref download docutils literal"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">transforms_tutorial.ipynb</span></code></a></div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="http://sphinx-gallery.readthedocs.io">Generated by Sphinx-Gallery</a></p>
</div>
</div>


          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2016 The Matplotlib development team.
      Last updated on Apr 27, 2017.
      Created using <a
href="http://sphinx-doc.org/">Sphinx</a> 1.5.5.
    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
  <!--Flipcause Integration v3.0// Flipcause Integration Instructions:
Install the following code block once in the website Header (after <head> tag) -->

<style>

.fc-black_overlay{
display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;
background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;
}

.fc-white_content {
opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;
position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;
}

.fc-main-box{
opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;
}

.fc-widget_close{
opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);
position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;
}

.floating_button{
display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;
position:fixed; z-index:999999; overflow: auto;
}

@keyframes backfadesin {
   from { opacity:0; }
   to {opacity:.5;}
}

@-moz-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-webkit-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-o-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}


@-ms-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; transform: translateY(20px);}
   100% {opacity: 1; transform: translateY(0);}
}

@-moz-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -moz-transform: translateY(20px);}
   100% {opacity: 1; -moz-transform: translateY(0);}
}

@-webkit-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -webkit-transform: translateY(20px);}
   100% {opacity: 1; -webkit-transform: translateY(0);}
}

@-o-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -o-transform: translateY(20px);}
   100% {opacity: 1; -o-transform: translateY(0);}
}

@-ms-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -ms-transform: translateY(20px);}
   100% {opacity: 1; -ms-transform: translateY(0);}
}

</style>

<script>

function open_window(cause_id) {
var  protocol=String(document.location.protocol);
var new_url;
if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)){
new_url="https://www.flipcause.com/widget/"+cause_id
window.open(new_url);
}

else {
document.getElementById("fc-fade").style.display = "block";
document.getElementById("fc-fade").style.webkitAnimation = "backfadesin 1s";
document.getElementById("fc-fade").style.animation = "backfadesin 1s";
document.getElementById("fc-fade").style.mozAnimation = "backfadesin 1s";
document.getElementById("fc-light").style.display = "block";
document.getElementById("fc-light").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-light").style.animation = "fadesin 1.5s";
document.getElementById("fc-light").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-main").style.display = "block";
document.getElementById("fc-main").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-main").style.animation = "fadesin 1.5s";
document.getElementById("fc-main").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-close").style.display = "block";
document.getElementById("fc-close").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-close").style.animation = "fadesin 1.5s";
document.getElementById("fc-close").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.display = "block";
document.getElementById("fc-myFrame").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.animation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").src="https://www.flipcause.com/widget/"+cause_id;
}
}


function close_window() {
document.getElementById("fc-fade").style.display="none";
document.getElementById("fc-light").style.display="none";
document.getElementById("fc-main").style.display="none";
document.getElementById("fc-close").style.display="none";
document.getElementById("fc-myFrame").style.display="none";
}

</script>

<div id="fc-fade" class="fc-black_overlay" onclick="close_window()"></div>
<div id="fc-light" class="fc-white_content">
<div id="fc-main" class="fc-main-box">
<div id="fc-close" class="fc-widget_close" onclick="close_window()">
</div><iframe id="fc-myFrame" iframe height="580" width="925" style="border: 0;
border-radius:5px 5px 5px 5px; box-shadow:0 0 8px rgba(0, 0, 0, 0.5);" scrolling="no" src=""></iframe></div>
</div>

<!--END Flipcause Main Integration Code-->
</footer>
</html>